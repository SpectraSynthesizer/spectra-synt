/*
Copyright (c) since 2015, Tel Aviv University and Software Modeling Lab

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Tel Aviv University and Software Modeling Lab nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Tel Aviv University and Software Modeling Lab 
BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT 
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
*/

package tau.smlab.syntech.gameinput.model;

import java.util.HashSet;
import java.util.Set;

/**
 * A class to represent a regular expression.<br> 
 * The goal is to represent a regexp in a more natural and simple way than it is represented 
 * by the class 'RegExp', generated by xtext
 *
 * @param left
 * 
 * @param right - left and right are SpecRegExp. This fields are used for the 
 * case of a binary regular expression: intersection, union and concatenation.<br>
 * In caseof a unary expression (complement etc.) only left is used.
 * 
 * @param from
 * 
 * @param to  - from and to are used for the case of a RANGE regular expression. 
 * Namely, to express a number of repetition of a regular expression in a given range 
 * i.e. reg^n where n in {from=x, to=y}.
 * 
 * @param name  - for the case of a variable, to specify its name.
 * 
 * @param values - for the case of a non-boolean variables. 
 * To specify the set of values accepted by the regular expression.
 * 
 * @param kind - to specify the main operator of the  regular expression 
 * e.g. union, complement, variable etc.
 */



public class SpecRegExp {

//  private int traceId;
  
  private SpecRegExp left;
  private SpecRegExp right;
  private int from;
  private int to;
  private String name;
  private Set<Integer> values;
  
  public enum Quantifier {
	  
	  COMPLEMENT,
	  ZERO_OR_MORE,	
	  ONE_OR_MORE,
	  ZERO_OR_ONE,
	  EXACT_REPETITION,
	  AT_LEAST,
	  RANGE,
	  UNION,
	  INTERSECTION,
	  CONCAT,
	  VAR,
	  NEGVAR,
	  VAL,
	  EMPTY
  };
  
  private Quantifier kind;
  


  
  // Constructor for a variable or a negated variable expression 
  public SpecRegExp(String name,boolean isneg) {
	  Set<Integer> tmp = new HashSet<>(); 
	  if (isneg) {
		  this.kind = Quantifier.NEGVAR;
		  tmp.add(0);
	  }
	  else {
		  this.kind = Quantifier.VAR;
		  tmp.add(1);
	  }
	  this.values = tmp;
	  this.name=name;
  }
  
  
  // Constructor for a non-boolean variable expression 
  public SpecRegExp(String name, Set<Integer> values) {

	  this.kind = Quantifier.VAR; 
	  this.name=name;
	  this.values=values; 
  }
  

  // Constructor for a boolean value 
  public SpecRegExp(String name) {
	  this.kind = Quantifier.VAL;
	  this.name = name;
  }

  
  
  // Constructor for the empty string regular expression
  public SpecRegExp() {
	  this.kind = Quantifier.EMPTY;
  }
  
  
  // Constructor for a unary regular expression with no range 
  public SpecRegExp(SpecRegExp left, Quantifier kind) {
	  this.left=left;
	  this.kind=kind;
  }
  
  
  // Constructor for an "exact" or "at least" repetition regular expression
  public SpecRegExp(SpecRegExp left, Quantifier kind, int from) {
	  this.left=left;
	  this.kind=kind;
	  this.from = from;
  }
  
  
  // Constructor for a "range" regular expression
  public SpecRegExp(SpecRegExp left, int from, int to) {
	  this.kind = Quantifier.RANGE;
	  this.left=left;
	  this.from=from;
	  this.to=to;
  }
  
  
  // A constructor for a binary regular expression
  public SpecRegExp(SpecRegExp left, SpecRegExp right, Quantifier kind) {
	  this.left = left;
	  this.right=right;
	  this.kind=kind;
  }
  
  public Quantifier getKind(){
	  return kind;
  }
  
  public SpecRegExp getLeft(){
	  return left;
  }
  
  
  public SpecRegExp getRight(){
	  return right;
  }
  
  
  public String getName(){
	  return name;
  }
  
  
  public int getFrom(){
	  return from;
  }
  
  
  public int getTo(){
	  return to;
  }
  
  public Set<Integer> getValues(){
	  return values;
  } 
  
  

  
}
